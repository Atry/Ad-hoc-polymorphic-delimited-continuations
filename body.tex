\section{Introduction}
\label{introduction}

Traditionally, the capable of a general purpose language can be extended to special domain by creating an embedded DSL (Domain-Specific Language). For example, Akka provides a DSL to create finite-state machines \cite{lightbend2017akka}, which consists of some domain-specific operators including \lstinline{when}, \lstinline{goto}, \lstinline{stay}, etc. Although those operators looks similar to native control flow, they are not able to be embedded in \lstinline{if}, \lstinline{while} or \lstinline{try} blocks, because Akka's DSL split code into small closures, preventing ordinary control flows from crossing the boundary of those closures. TensorFlow's control flow operations \cite{abadi2016tensorflow} and Caolan's async library \cite{caolan2017async} are other examples of reinventing control flow in eDSL.

It's too trivial to reinvent the whole set of control flows for each DSL. A simpler approach is only implementing a minimal interface required for control flows for each domain, while the syntax of other control flow operations are derived from the interface, shared between different domains. In Haskell and other functional programming language, monads are used as the generic interface of control flow \cite{wadler1990comprehending,wadler1992essence,jones1993composing}. Scala implementations of monads are provided by Scalaz \cite{kenji2017scalaz}, Cats \cite{typelevel2017cats} and Algebird \cite{twitter2016algebird}. A DSL author only have to implement \lstinline{bind} and \lstinline{point} functions in \lstinline{Monad} type class, and all the derived control flow operations like \lstinline{whileM} or \lstinline{ifM} are available. In addition, those monadic data type can be created and composed from \lstinline{do} or \lstinline{for} comprehension \cite{jones1998haskell,odersky2004scala}. For example, you can use the same \lstinline{scalaz.syntax} or \lstinline{for} comprehension to create random value generators \cite{nilsson2015scalacheck} and data-binding expressions \cite{yangbo2016binding}, as long as there are \lstinline{Monad} instances for data types \lstinline{org.scalacheck.Gen} and \lstinline{com.thoughtworks.binding.Binding} respectively.

An idea to avoid inconsistency between domain-specific control flow and ordinary control flow is converting ordinary control flow to domain-specific control flow at compiler time. For example, Scala Async provides a macro to generate asynchronous control flow \cite{haller2013sip}, allowing normal synchronous code inside a \lstinline{scala.async} block to run asynchronously. This approach can be generalized to any monadic data types. ThoughtWorks Each \cite{yangbo2015each}, Monadless \cite{flavio2017monadless}, effectful \cite{crockett2013effectful} and !-notation in Idris \cite{brady2013idris} are compiler-time transformers to convert source code of ordinary control flow to monadic control flow. For example, with the help of ThoughtWorks Each, Binding.scala\cite{yangbo2016binding} can be used to create reactive HTML template from ordinary Scala control flow.

Another generic interface of control flow is continuation, which is known as the mother of all monads \cite{piponi2008mother}, where control flows in specific domain can be supported by specific final result types of continuations. Scala Continuations \cite{rompf2009implementing} and Stateless Future \cite{yangbo2014stateless} are two delimited continuation implementations. Both projects can convert ordinary control flow to continuation-passing style closure chains at compiler time. For example, Stateless Future Akka \cite{yangbo2014statelessfutureakka}, based on `stateless-future`, provides a special final result type for akka actors. Unlike reinvented control flows in \lstinline{akka.actor.AbstractFSM}, users can create complex finite-state machines from simple ordinary control flows along with Stateless Future Akka's domain-specific operator \lstinline{nextMessage}.

All the previous approaches lack of the ability to collaborate with other DSLs. Each of the above DSLs can be exclusively enabled in a code block. Scala Continuations enables calls to \lstinline{@cps} method in \lstinline{reset} blocks, and ThoughtWorks Each enables the magic `each` method for \lstinline{scalaz.Monad} in \lstinline{monadic} blocks. It was impossible to enable both DSL in one function.

This paper describes a novel approach to resolve the collaboration problem, and presents an implementation in Scala, the framework \textit{Dsl.scala}.

\textit{Dsl.scala} allows library authors to create special keywords for language features that were usually implemented by the compiler. Those keywords are collaborative, as a library user can create one function that contains interleaved keywords from different vendors, along with ordinary Scala control flows.

% TODO: link to other section.
\textit{Dsl.scala} also ships with some built-in keywords, including:
\begin{itemize}
  \item The \lstinline{Shift} keyword for asynchronous programming, similar to the \lstinline{await} and \lstinline{async} keywords in C\#, Python and JavaScript.
  \item The \lstinline{Yield} keyword for generating lazy streams, similar to the \lstinline{yield} keyword in C\#, Python and JavaScript.
  \item The \lstinline{Fork} keyword for duplicating current thread, similar to the \lstinline{fork} system call in POSIX.
  \item The \lstinline{AutoClose} keyword to automatically close resources when exiting a scope, similar to the destructor feature in C++.
  \item The \lstinline{Monadic} keyword for creating Scalaz \cite{kenji2017scalaz} or Cats \cite{typelevel2017cats} monadic control flow, similar to the !-notation in Idris\cite{brady2013idris}.
\end{itemize}
 


%  Our approach is based on two assumptions:
% \begin{enumerate}
%   \item The return type is the specific domain of DSL.
%   \item A language feature should be adaptive to various domains along with the hosting language control flow.
% \end{enumerate}
% % By combining of the two assumptions, we build a DSL framework, and some examples of DSLs in various domains, including asynchronous or parallel programming, lazy stream generation, resource management.

% % A DSL keyword in our framework can be adaptive to its contextual domain. A DSL user can create a single function that contains interleaved DSLs implemented by different vendors, along with ordinary Scala control flows.

% % We also provide some adapters to monad, which can be also used as a alternative syntactic sugar of monad comprehension.

% % DSL operators in our framework can be adaptive to its specific domain. A DSL user can create a single function that contains interleaved different DSLs implemented from different vendors, along with ordinary Scala control flows.

 
% % In functional programming, imperative control flow can be composed from monads \cite{wadler1990comprehending,wadler1992essence,jones1993composing}.
% % Along with monad transformers \cite{liang1995monad} and \lstinline{do} or \lstinline{for} comprehension \cite{jones1998haskell,odersky2004scala}, the ability of control flow

% % We show how a set of building blocks can be used to construct
% % programming language interpreters, and present implementations
% % of such building blocks capable of supporting many
% % commonly known features, including simple expressions,
% % three different function call mechanisms (call-by-name, call-by-value and lazy evaluation), references and assignment,
% % nondeterminism, first-class continuations, and program tracing.

\section{Using library-defined keywords}

In this section, we will show some use cases from the keyword user's perspective.

\subsection{Use case: a pseudo-random number generator}

Suppose Alice is creating an Xorshift pseudo-random number generator \cite{marsaglia2003xorshift}, and she wants to store the generated numbers in a lazily evaluated infinite stream. 

The usage of Alice's pseudo-random number generator is shown as below:

\begin{lstlisting}[caption={Using Alice's pseudo-random number generator},label={generatedNumbers}]
val generatedNumbers = aliceRandomGenerator(seed = 2463534242)
println(generatedNumbers(0))
println(generatedNumbers(1))
println(generatedNumbers(2))
\end{lstlisting}

Alice is a functional programming language developer. She wants to avoid mutable variables in the implementation. Unfortunately, a pseudo-random number generator usually has an internal state that are changed during generate new random number.

With the help of the built-in keyword \lstinline{Yield} from \textit{Dsl.scala}, Alice can implement the generator as a recursive function that produce the next random number in each iteration.

\begin{lstlisting}[caption={The implementation of Alice's pseudo-random number generator},label={generatedNumbers}]
import com.thoughtworks.dsl.keywords.Yield
def aliceRandomGenerator(seed: Int): Stream[Int] = {
  val tmp1 = seed ^ (seed << 13)
  val tmp2 = tmp1 ^ (tmp1 >>> 17)
  val tmp3 = tmp2 ^ (tmp2 << 5)
  !Yield(tmp3)
  aliceRandomGenerator(tmp3)
}
\end{lstlisting}

\lstinline{aliceRandomGenerator} does not throw a \lstinline{StackOverflowError} because the execution of \lstinline{aliceRandomGenerator} will be paused at the keyword \lstinline{Yield}, and it will be resumed when the caller is looking for the next number.

\lstinline{Yield} is a keyword to produce a value for a lazily evaluated \lstinline{Stream}, similar to the \lstinline{yield} keyword in C\#, JavaScript or Python. That is to say, \lstinline{Stream} is the domain where the domain-specific keyword \lstinline{Yield} can be used. More generally, \textbf{the return type is the specific domain of DSL.}

\subsection{Use case: logging}

In this use case, we will demonstrate how to add the logging feature to existing functions using the \lstinline{Yield} keyword.

Suppose Bob has a function to parse JSON text. The parser is fault-tolerant, since it returns the \lstinline{defaultValue} for invalid input  (Listing \ref{bobParser}).

\begin{lstlisting}[caption={The original implementation of Bob's parser},label={bobParser}]
import scala.util.parsing.json._
def bobParser(jsonContent: String, defaultValue: JSONType): JSONType = {
  JSON.parseRaw(jsonContent) match {
    case Some(json) =>
      callback(json)
    case None =>
      callback(defaultValue)
  }
}
\end{lstlisting}

Then, Bob wants to add the logging feature to his existing parser. He learnt from Alice's use case, and wonders if he can \lstinline{Yield} log messages to a \lstinline{Stream[String]} during parsing.

However, unlike Alice's case, Bob's parser should return both the parsed JSON objects and the collected logs. It's impossible in C\#'s \lstinline{yield}, because \lstinline{yield} does not work in a method that returns a JSON object.

Bob resolves the problem by creating a delimited continuation. The parsed JSON object is handled by a callback function instead of return value. Thus the return value is still a \lstinline{Stream}, allowing \lstinline{Yield}ing log messages (Listing \ref{bobLoggingParser}).

\begin{lstlisting}[caption={The implementation of Bob's logging parser},label={bobLoggingParser}]
import com.thoughtworks.dsl.Dsl.!!
def bobLoggingParser(jsonContent: String, defaultValue: JSONType): Stream[String] !! JSONType = { (callback: JSONType => Stream[String]) =>
  !Yield(s"I am going to parse the JSON text $jsonContent...")
  JSON.parseRaw(jsonContent) match {
    case Some(json) =>
      !Yield(s"Succeeded to parse $jsonContent")
      callback(json)
    case None =>
      !Yield(s"Failed to parse $jsonContent")
      callback(defaultValue)
  }
}
\end{lstlisting}

The return type of Bob's new parser is \lstinline{Stream[String] !! JSONType}, which is an alias to the delimited continuation \lstinline{(JSONType => Stream[String]) => Stream[String]}, indicating it produces both a \lstinline{scala.util.parsing.json.JSONType} and a \lstinline{Stream} of logs.

After Bob created the first version of delimited continuation, he then found that the closure can be simplified with the help of Scala's placeholder syntax (Listing \ref{bobLoggingParserUnderscore}).

\begin{lstlisting}[caption={The implementation of Bob's logging parser, the underscore placeholder version},label={bobLoggingParserUnderscore}]
def bobLoggingParserUnderscore(jsonContent: String, defaultValue: JSONType): Stream[String] !! JSONType = _ {
  !Yield(s"I am going to parse the JSON text $jsonContent...")
  JSON.parseRaw(jsonContent) match {
    case Some(json) =>
      !Yield(s"Succeeded to parse $jsonContent")
      json
    case None =>
      !Yield(s"Failed to parse $jsonContent")
      defaultValue
  }
}
\end{lstlisting}

Alternately, Bob can use the pre-defined function \lstinline{delay} \footnote{The difference between underscore and \lstinline{delay} will be discussed in Section \ref{Creating library-defined keywords}} instead of the underscore placeholder (Listing \ref{bobLoggingParserDelay}). 

\begin{lstlisting}[caption={The implementation of Bob's logging parser, the delay version},label={bobLoggingParserDelay}]
import com.thoughtworks.dsl.Dsl.delay
def bobLoggingParserDelay(jsonContent: String, defaultValue: JSONType): Stream[String] !! JSONType = delay {
  !Yield(s"I am going to parse the JSON text $jsonContent...")
  JSON.parseRaw(jsonContent) match {
    case Some(json) =>
      !Yield(s"Succeeded to parse $jsonContent")
      json
    case None =>
      !Yield(s"Failed to parse $jsonContent")
      defaultValue
  }
}
\end{lstlisting}

Then, the user of Bob's parser calls \lstinline{bobLoggingParserDelay} to handle both results (Listing \ref{usingBobLoggingParserDelay}):

\begin{enumerate}
  \item The JSON result in a callback function.
  \item The logs from return value.
\end{enumerate}

\begin{lstlisting}[caption={Using Bob's parser},label={usingBobLoggingParserDelay}]
val logs = bobLoggingParserDelay("""{"key":"value"}""", JSONArray(Nil)) { json =>
  json should be(JSONObject(Map("key" -> "value")))
  Stream("done")
}
logs should be(
  Stream(
    "I am going to parse the JSON text {\"key\":\"value\"}...",
    "Succeeded to parse {\"key\":\"value\"}",
    "done"
  )
)
\end{lstlisting}

There are only few changes between Bob's \lstinline{bobLoggingParserDelay} and the original \lstinline{bobParser} in order to enable the \lstinline{Yield} keyword. Generally, a keyword user can introduce a new domain (i.e. the return value) to an existing method with the two changes:

\begin{enumerate}
  \item Inserting a \lstinline{NewDomain!!} prefix to the return type (\lstinline{Stream[String]!!} in Bob's case).
  \item Inserting an \lstinline{delay} character before the method block body.
\end{enumerate}

\subsection{Use case: reading lines from a resource}

Carol

\section{Creating library-defined keywords}
\label{Creating library-defined keywords}


% use Scala's underscore as a syntactic sugar to simplify his code. 


% how a keyword user can create a custom collection on RAII-managed resource by using \lstinline{Yield} and \lstinline{AutoClose} keywords together.

\section{Conclusion}
\label{conclusion}


\clearpage
% Appendix
\appendix

\printglossary

\begin{acks}
% TODO:
\end{acks}

% Bibliography
\bibliography{bibliography}
